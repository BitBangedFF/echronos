Task: rDzBUS-easier_third_party_library_inclusion
==============================================================================

Motivation
----------

- Currently there isn't really an easy way of using a lot of headers (as in common
 when working with third-party libraries), in an eChronos package.

- A possible solution is to just create a .c file that contains a large schema
forcing prj to include all of the headers like:

    /*<module>
    <headers>
        <header path="clock_driver.h" />
        <header path="smaccm_decls.h" />
        <header path="smaccm_receiver2.h" />
        <header path="smaccm_receiver.h" />
        <header path="smaccm_sender.h" />
        <header path="smaccm_test1_impl_types.h" />
    </headers>
    </module>*/
    ... all the c code (this example from Ihor)

- However the problem with this is interdependency using relative paths. For example,
in the TI libraries, there are hundreds of header files & c files with include
declarations of the form:

    #include <stdbool.h>
    #include <stdint.h>
    #include "inc/hw_memmap.h"
    #include "inc/hw_types.h"
    #include "inc/hw_ints.h"
    #include "driverlib/gpio.h"
    #include "driverlib/pin_map.h"
    #include "driverlib/rom.h"
    #include "driverlib/rom_map.h"
    #include "driverlib/sysctl.h"
    #include "driverlib/interrupt.h"
    ...

- This means that, as prj moves every interdependent file to one directory before final
compilation, all of these relative links break

Goals
--------

- Make it easier to include large sets of third-party libraries with prj. 

- Below is what I am currently using; however it would be good to have some discussion
on how best to approach this

Test Plan
---------

- Perform build tests to ensure that adding this functionality doesn't adversely affect
other areas of prj.

Sample Implementation
---------------------

- In prj/app/prj.py, it's pretty simple just to add a couple member functions.

- At the bottom of System.__init__, add:

    self.extra_includes = []

- And then add/modify these 2 methods:

    @property
    def include_paths(self):
        return [self.output] + self.extra_includes

    def add_include_path(self, path):
        self.extra_includes.append(path)

- IMPORTANT: There is a redundant syntax check in the vector table build script,
which you have to remove in order for this modification to work. For ARM,
it's at: packages/armv7/vectable.py:106

    for c_file in system.c_files:
        with open(c_file) as f:
            try:
                p.parse(f.read(), c_file)
            except ply.cpp.CppError as e:
                raise SystemBuildError(str(e))

- Change this to:

    for c_file in system.c_files:
        with open(c_file) as f:
            try:
                p.parse(f.read(), c_file)
            except ply.cpp.CppError as e:
                pass

Now in your build script it's much simpler to include headers directory-wise:

    def system_build(system):
        ti_lib_dir = os.getcwd() + "/packages/machine-tm4c1294-launchpad/ti_libs/"

        system.add_include_path(ti_lib_dir)
        system.add_include_path(ti_lib_dir + "inc")
        system.add_include_path(ti_lib_dir + "stdlib_hook")
        system.add_include_path(ti_lib_dir + "examples/boards/ek-tm4c1294xl")
        system.add_include_path(ti_lib_dir + "third_party/lwip-1.4.1/src/include")
        system.add_include_path(ti_lib_dir + "third_party/lwip-1.4.1/apps")
        system.add_include_path(ti_lib_dir + "third_party/lwip-1.4.1/ports/tiva-tm4c129/include")
        system.add_include_path(ti_lib_dir + "third_party/lwip-1.4.1/src/include/ipv4")

        # ... rest of build script


