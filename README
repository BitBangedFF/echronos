BRTOS Project
==============

The BRTOS project contains everything a developer should need to create the various BRTOS product deliverables.

The `x.py` script should provide an interface to all things that a developer may want to do with the project (with the exception of revision control, for which `git` is used).
For example, to build the project's deliverables use `x.py build` (this is the default if just running `x.py`).
To run static analysis for the *prj* part of the project use `x.py prj-check`.
To run tests for the *prj* part of the project use `x.py prj-test`.
`x.py` is a Python 3 script, so ensure that Python 3.3 is installed.

The script is called `x.py` simply because it is short and quick to type (additionally, since it is a multi-purpose tool there is not any other good name to assign it).
Note: The `.py` extension is important to ensure it works on Windows platforms.

This project is developed on Linux, OS X and Windows platforms.
POSIX shell scripts and Windows batch files are discouraged in favour of using Python as a general purpose scripting language.
Although Python code can be more verbose than either shell or batch languages the fact that it is cross-platform makes up for this.

Any tools other than Python, git, and standard tools that are shipped with the host platform should be installed in `external_tools`.
The project should as much as possible not require special installation of tools, or rely on tools that are installed in the operating system.

Some projects target POSIX.
In these cases the host platform should provide a `gcc` compiler.
This is usually pre-installed on Linux and OS X.
On Windows the **MinGW** port of `gcc` should be installed.

Any additional project related functionality should be added as sub-commands to the `x.py` script.
Note: As the `x.py` script grows it may be refactored in to multiple Python modules.

The `prj` directory contains everything related to the *prj* tool.

The `release` directory is created when building the project, and contains all releasable artifacts.
Anything released to a third-party must come from the `release` directory.


Project Management
-------------------

The `pm` directory contains project management related meta-data.
This meta-data is crucial for documenting that our processes are correctly followed.

All development is performed as individual *tasks*.
Each task is documented in the `pm/tasks` directory.
Each task is given a unique tag, which is generated by the QMS `gen_tag.py` script.
The task identifier is in the form <tag>-<description>.
Description should be all lowercase, ASCII, with spaces represented as dashes.
In the case where there may be multiple similar tasks an integer suffix may be applied.
E.g.: large-task-1, large-task-2, etc.

A task must be reviewed before it is completed.
The task is reviewed against the goals of the task.
The developer is responsible for ensuring that the level of review is appropriate for the goals of the task.

Each sub-project should include a `reqs` file, which defines the requirements for the sub-project.
Every part of the implementation should relate back to a stated requirement.
The format of a single requirement is a set of single line headers of the form "key: value", followed by a single line, then one or more lines describing the requirement, formatted using markdown.
At a minimum each requirement must have a `tag` header, which contains a unique tag generated by the QMS `gen_tag.py` script.
Requirements are separated by two blank lines.

Additional header fields will be defined in the future (and may capture such things as priority, relationships between requirements, etc).

In the future, it may be possible to extract requirements from additional sources, such as source code or end-user documentation.

Individual tasks may update requirements, implementation or both.
It is not necessary that an individual task fulfils all requirements for a given sub-project (unless that is the goal of the task).

RTOS composition / generation
------------------------------

This project should contain the tools required for the team to generate and build a number of different RTOSes.
Each RTOS is made up from a number of separate components (which can hopefully be individually tested, verified and reused.)
This can make for some conceptual complexity.

There are multiple steps (for us as the RTOS generators) in building an end system.

Step 1: Create the RTOS itself using an `x.py` sub-command.
This is the first phase and takes the various components, and synthesises them into an RTOS.
The synthesised RTOS can be found in `packages.output`.
The source for these synthesises RTOS can be found in `packages.input`.

Step 2: Create a system using the RTOS using the `prj` tool.
This is the step that the end-user performs (the end-user only has access to the `prj` tool, not the `x.py`).
The end-user has a number of configuration elements available to them, but this is significantly reduced when compared to what can be done in the previous step.

System Setup
-------------

The project is very light on dependencies, and should be as self-contained as possible.
One major dependency is on a suitable Python interpreter.
Python 3.3 should be used (http://www.python.org/download/releases/3.3.0/).
On Linux and OS X this should be sufficient.

On Windows some additional setup is required.
The examples provided assume that on Windows the Python launcher for Windows (http://www.python.org/dev/peps/pep-0397/) has been setup correctly.
The launcher is used to launch the correct version of Python based on a shebang style line.
For this to work correctly there are three important settings that must be performed.
Firstly, an appropriate *association* must have been made, so that Windows knows what type of file `.py` files are.
This should have been done automatically during Python install, but can be verified with the following:

    c:\> assoc py
    .py=Python.File

Secondly, Windows must know how to correctly handle files with type `Python.File`.
This is handled by the `ftype` command.
You should see something similar to:

    c:\> ftype Python.File
    Python.File="C:\WINDOWS\py.exe" "%1" %*

Finally, the Windows command shell must know that `.py` files can be invoked direclty from the command line.
For this the `PATHEXT` environment must include `.PY` in the list of valid extensions.
This is not necessarily done by the Python installer, and may need to be done manually.

**Note**: examples in this document use a forward-slash (/) as the path separator.
Cygwin and Powershell will generally automatically convert these appropriately, however if using `cmd.com` you will likely need to manually convert path to use back-slash (\).

Systems that can be built
--------------------------

The following systems can be built:

`posix/hello/example`:

     $ ./prj/app/prj.py build posix/example/hello
     $ out/posix/example/hello/system

This should work on Linux, OS X or Windows.

`example/acamar-system`:

     $ ./prj/app/prj.py build acamar-system
     $ out/example/acamar-system/system

 This will only work on Linux, not OS X or Windows.
